{"ast":null,"code":"export default {\n  name: 'Count',\n  data() {\n    return {\n      n: 1 //步长默认为1\n    };\n  },\n\n  computed: {\n    school() {\n      return this.$;\n    }\n  },\n  methods: {\n    increment() {\n      console.log(this);\n      this.$store.dispatch('increment', this.n);\n    },\n    /* \r\n    \t像上面这个操作没有处理逻辑，调用dispatch()通知actions，actions收到后直接就调用commit()给mutations了\r\n    \t一般这种不需要逻辑处理的操作，可以直接调用commit()通知mutations操作数据。如下所示：\r\n    */\n    decrement() {\n      this.$store.commit('DECREMENT', this.n);\n    },\n    /* \r\n    \t下面两个操作需要处理逻辑，所以需要经过actions处理，所以需要调用dispatch()（当然完全可以将逻辑写在下面方法中，这里只是为了演示Vuex的流程，）\r\n    */\n    incrementOdd() {\n      this.$store.dispatch('incrementOdd', this.n);\n    },\n    incrementWait() {\n      this.$store.dispatch('incrementWait', this.n);\n    }\n  }\n};","map":{"version":3,"names":["name","data","n","computed","school","$","methods","increment","console","log","$store","dispatch","decrement","commit","incrementOdd","incrementWait"],"sources":["src/components/Count.vue"],"sourcesContent":["<template>\r\n\t<div>\r\n\t\t<!-- 下面插值语法中反复用到了$store.state，可以将该数据存储在计算属性中，减少代码冗余 -->\r\n\t\t<h1>我在{{$store.state.school}} 学习{{$store.state.subject}}</h1>\r\n\t\t<h1>当前求和为：{{$store.state.sum}}</h1>\r\n\t\t<h1>扩大十倍后：{{$store.getters.bigSum}}</h1>\r\n\t\t<!-- 下拉框选择增加步长 -->\r\n\t\t<select v-model.number=\"n\">\r\n\t\t\t<option value=\"1\">1</option>\r\n\t\t\t<option value=\"2\">2</option>\r\n\t\t\t<option value=\"3\">3</option>\r\n\t\t</select>\r\n\t\t<button @click=\"increment\">+</button>\r\n\t\t<button @click=\"decrement\">-</button>\r\n\t\t<button @click=\"incrementOdd\">当前求和为奇数再加</button>\r\n\t\t<button @click=\"incrementWait\">等一等再加</button>\r\n\t</div>\r\n</template>\r\n\r\n<script>\r\n\texport default {\r\n\t\tname:'Count',\r\n\t\tdata() {\r\n\t\t\treturn {\r\n\t\t\t\tn:1, //步长默认为1\r\n\t\t\t}\r\n\t\t},\r\n\t\tcomputed:{\r\n\t\t\tschool(){\r\n\t\t\t\treturn this.$\r\n\t\t\t}\r\n\t\t},\r\n\t\tmethods: {\r\n\t\t\tincrement(){\r\n\t\t\t\tconsole.log(this)\r\n\t\t\t\tthis.$store.dispatch('increment',this.n)\r\n\t\t\t},\r\n\t\t\t/* \r\n\t\t\t\t像上面这个操作没有处理逻辑，调用dispatch()通知actions，actions收到后直接就调用commit()给mutations了\r\n\t\t\t\t一般这种不需要逻辑处理的操作，可以直接调用commit()通知mutations操作数据。如下所示：\r\n\t\t\t*/\r\n\t\t\tdecrement(){\r\n\t\t\t\tthis.$store.commit('DECREMENT',this.n)\r\n\t\t\t},\r\n\t\t\r\n\t\t\t/* \r\n\t\t\t\t下面两个操作需要处理逻辑，所以需要经过actions处理，所以需要调用dispatch()（当然完全可以将逻辑写在下面方法中，这里只是为了演示Vuex的流程，）\r\n\t\t\t*/\r\n\t\t\tincrementOdd(){\r\n\t\t\t\tthis.$store.dispatch('incrementOdd',this.n)\r\n\t\t\t},\r\n\t\t\tincrementWait(){\r\n\t\t\t\tthis.$store.dispatch('incrementWait',this.n)\r\n\t\t\t},\r\n\t\t},\r\n\t}\r\n</script>\r\n\r\n<style lang=\"css\">\r\n\tbutton{\r\n\t\tmargin-left: 5px;\r\n\t}\r\n</style>\r\n"],"mappings":"AAoBA;EACAA,IAAA;EACAC,KAAA;IACA;MACAC,CAAA;IACA;EACA;;EACAC,QAAA;IACAC,OAAA;MACA,YAAAC,CAAA;IACA;EACA;EACAC,OAAA;IACAC,UAAA;MACAC,OAAA,CAAAC,GAAA;MACA,KAAAC,MAAA,CAAAC,QAAA,mBAAAT,CAAA;IACA;IACA;AACA;AACA;AACA;IACAU,UAAA;MACA,KAAAF,MAAA,CAAAG,MAAA,mBAAAX,CAAA;IACA;IAEA;AACA;AACA;IACAY,aAAA;MACA,KAAAJ,MAAA,CAAAC,QAAA,sBAAAT,CAAA;IACA;IACAa,cAAA;MACA,KAAAL,MAAA,CAAAC,QAAA,uBAAAT,CAAA;IACA;EACA;AACA"},"metadata":{},"sourceType":"module","externalDependencies":[]}