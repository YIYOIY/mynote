{"ast":null,"code":"// 导入mapState和mapGetters\nimport { mapState, mapGetters } from 'vuex';\nexport default {\n  name: 'Count',\n  data() {\n    return {\n      n: 1 //步长默认为1\n    };\n  },\n\n  /* \r\n  computed:{\r\n  \tschool(){\r\n  \t\treturn this.$store.state.school\r\n  \t},\r\n  \tsubject(){\r\n  \t\treturn this.$store.state.subject\r\n  \t},\r\n  \tsum(){\r\n  \t\treturn this.$store.state.sum\r\n  \t},\r\n  \tbigSum(){\r\n  \t\treturn this.$store.getters.bigSum\r\n  \t}\r\n  },\r\n  \t上面这样写又出现了代码冗余，观察发现只需要计算属性名和state对象中的属性名即可获得计算属性。\r\n  \t因此导入Vuex中的一个方法可以帮我们简写计算属性：import {mapState} from 'vuex'\r\n  \t该方法的参数可以是一个对象，也可以是一个数组。该方法返回一个对象。\r\n  \t\t\t对象形式的参数：mapState({school:'school',subject:'subject',sum:'sum'})\r\n  \t对象中是一个个的键值对，键代表计算属性的名字，值代表state中的属性名。注意值如果不是变量名一定要加引号。\r\n  \t这里不能使用对象的简写形式，因为对象的简写形式是键和值相同，值要是一个变量且变量名要和键名相同才能简写。而这里值不是一个变量，只是一个普通字符串。\r\n  \t\t\t上面对象形式的参数不能使用简写形式，使用数组形式的参数可以简写：mapState([school,subject,sum])\r\n  \t使用数组形式的参数的前提是计算属性名和state对象中的属性名是同名的。\r\n  \t若计算属性名和state对象中的属性名不同，则只能使用对象形式的参数。比如mapState({xuexiao:'school'})\r\n  */\n  // mapState()返回的是一个对象，而对象不能直接写在computed对象中，因此可以使用展开运算符，将对象中的属性添加到computed\n  computed: {},\n  methods: {\n    increment() {\n      console.log(this);\n      this.$store.dispatch('increment', this.n);\n    },\n    /* \r\n    \t像上面这个操作没有处理逻辑，调用dispatch()通知actions，actions收到后直接就调用commit()给mutations了\r\n    \t一般这种不需要逻辑处理的操作，可以直接调用commit()通知mutations操作数据。如下所示：\r\n    */\n    decrement() {\n      this.$store.commit('DECREMENT', this.n);\n    },\n    /* \r\n    \t下面两个操作需要处理逻辑，所以需要经过actions处理，所以需要调用dispatch()（当然完全可以将逻辑写在下面方法中，这里只是为了演示Vuex的流程，）\r\n    */\n    incrementOdd() {\n      this.$store.dispatch('incrementOdd', this.n);\n    },\n    incrementWait() {\n      this.$store.dispatch('incrementWait', this.n);\n    }\n  }\n};","map":{"version":3,"names":["mapState","mapGetters","name","data","n","computed","methods","increment","console","log","$store","dispatch","decrement","commit","incrementOdd","incrementWait"],"sources":["src/components/Count.vue"],"sourcesContent":["<template>\r\n\t<div>\r\n\t\t<!-- 下面插值语法中反复用到了$store.state，可以将该数据存储在计算属性中，减少代码冗余 -->\r\n\t\t<!-- <h1>我在{{$store.state.school}} 学习{{$store.state.subject}}</h1> -->\r\n\t\t<!-- <h1>当前求和为：{{$store.state.sum}}</h1> -->\r\n\t\t<!-- <h1>扩大十倍后：{{$store.getters.bigSum}}</h1> -->\r\n\r\n\t\t<!-- 这样就比上面简洁多了 -->\r\n\t\t<h1>我在{{school}} 学习{{subject}}</h1>\r\n\t\t<h1>当前求和为：{{sum}}</h1>\r\n\t\t<h1>扩大十倍后：{{bigSum}}</h1>\r\n\r\n\r\n\t\t<!-- 下拉框选择增加步长 -->\r\n\t\t<select v-model.number=\"n\">\r\n\t\t\t<option value=\"1\">1</option>\r\n\t\t\t<option value=\"2\">2</option>\r\n\t\t\t<option value=\"3\">3</option>\r\n\t\t</select>\r\n\t\t<button @click=\"increment\">+</button>\r\n\t\t<button @click=\"decrement\">-</button>\r\n\t\t<button @click=\"incrementOdd\">当前求和为奇数再加</button>\r\n\t\t<button @click=\"incrementWait\">等一等再加</button>\r\n\t</div>\r\n</template>\r\n\r\n<script>\r\n\t// 导入mapState和mapGetters\r\n\timport {mapState,mapGetters} from 'vuex'\r\n\texport default {\r\n\t\tname:'Count',\r\n\t\tdata() {\r\n\t\t\treturn {\r\n\t\t\t\tn:1, //步长默认为1\r\n\t\t\t}\r\n\t\t},\r\n\t\t/* \r\n\t\tcomputed:{\r\n\t\t\tschool(){\r\n\t\t\t\treturn this.$store.state.school\r\n\t\t\t},\r\n\t\t\tsubject(){\r\n\t\t\t\treturn this.$store.state.subject\r\n\t\t\t},\r\n\t\t\tsum(){\r\n\t\t\t\treturn this.$store.state.sum\r\n\t\t\t},\r\n\t\t\tbigSum(){\r\n\t\t\t\treturn this.$store.getters.bigSum\r\n\t\t\t}\r\n\t\t},\r\n\t\t\t上面这样写又出现了代码冗余，观察发现只需要计算属性名和state对象中的属性名即可获得计算属性。\r\n\t\t\t因此导入Vuex中的一个方法可以帮我们简写计算属性：import {mapState} from 'vuex'\r\n\t\t\t该方法的参数可以是一个对象，也可以是一个数组。该方法返回一个对象。\r\n\r\n\t\t\t对象形式的参数：mapState({school:'school',subject:'subject',sum:'sum'})\r\n\t\t\t对象中是一个个的键值对，键代表计算属性的名字，值代表state中的属性名。注意值如果不是变量名一定要加引号。\r\n\t\t\t这里不能使用对象的简写形式，因为对象的简写形式是键和值相同，值要是一个变量且变量名要和键名相同才能简写。而这里值不是一个变量，只是一个普通字符串。\r\n\r\n\t\t\t上面对象形式的参数不能使用简写形式，使用数组形式的参数可以简写：mapState([school,subject,sum])\r\n\t\t\t使用数组形式的参数的前提是计算属性名和state对象中的属性名是同名的。\r\n\t\t\t若计算属性名和state对象中的属性名不同，则只能使用对象形式的参数。比如mapState({xuexiao:'school'})\r\n\t\t*/\r\n\t\t// mapState()返回的是一个对象，而对象不能直接写在computed对象中，因此可以使用展开运算符，将对象中的属性添加到computed\r\n\t\tcomputed:{\r\n\r\n\t\t},\r\n\t\tmethods: {\r\n\t\t\tincrement(){\r\n\t\t\t\tconsole.log(this)\r\n\t\t\t\tthis.$store.dispatch('increment',this.n)\r\n\t\t\t},\r\n\t\t\t/* \r\n\t\t\t\t像上面这个操作没有处理逻辑，调用dispatch()通知actions，actions收到后直接就调用commit()给mutations了\r\n\t\t\t\t一般这种不需要逻辑处理的操作，可以直接调用commit()通知mutations操作数据。如下所示：\r\n\t\t\t*/\r\n\t\t\tdecrement(){\r\n\t\t\t\tthis.$store.commit('DECREMENT',this.n)\r\n\t\t\t},\r\n\t\t\r\n\t\t\t/* \r\n\t\t\t\t下面两个操作需要处理逻辑，所以需要经过actions处理，所以需要调用dispatch()（当然完全可以将逻辑写在下面方法中，这里只是为了演示Vuex的流程，）\r\n\t\t\t*/\r\n\t\t\tincrementOdd(){\r\n\t\t\t\tthis.$store.dispatch('incrementOdd',this.n)\r\n\t\t\t},\r\n\t\t\tincrementWait(){\r\n\t\t\t\tthis.$store.dispatch('incrementWait',this.n)\r\n\t\t\t},\r\n\t\t},\r\n\t}\r\n</script>\r\n\r\n<style lang=\"css\">\r\n\tbutton{\r\n\t\tmargin-left: 5px;\r\n\t}\r\n</style>\r\n"],"mappings":"AA2BA;AACA,SAAAA,QAAA,EAAAC,UAAA;AACA;EACAC,IAAA;EACAC,KAAA;IACA;MACAC,CAAA;IACA;EACA;;EACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;EAGA;EACAC,QAAA,GAEA;EACAC,OAAA;IACAC,UAAA;MACAC,OAAA,CAAAC,GAAA;MACA,KAAAC,MAAA,CAAAC,QAAA,mBAAAP,CAAA;IACA;IACA;AACA;AACA;AACA;IACAQ,UAAA;MACA,KAAAF,MAAA,CAAAG,MAAA,mBAAAT,CAAA;IACA;IAEA;AACA;AACA;IACAU,aAAA;MACA,KAAAJ,MAAA,CAAAC,QAAA,sBAAAP,CAAA;IACA;IACAW,cAAA;MACA,KAAAL,MAAA,CAAAC,QAAA,uBAAAP,CAAA;IACA;EACA;AACA"},"metadata":{},"sourceType":"module","externalDependencies":[]}