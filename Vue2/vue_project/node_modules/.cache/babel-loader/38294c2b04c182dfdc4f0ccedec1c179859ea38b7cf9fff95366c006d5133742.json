{"ast":null,"code":"// 导入mapState、mapGetters、mapActions、mapMutations\nimport { mapState, mapGetters, mapActions, mapMutations } from 'vuex';\nexport default {\n  name: 'Count',\n  data() {\n    return {\n      n: 1 //步长默认为1\n    };\n  },\n\n  /* \r\n  computed:{\r\n  \tschool(){\r\n  \t\treturn this.$store.state.school\r\n  \t},\r\n  \tsubject(){\r\n  \t\treturn this.$store.state.subject\r\n  \t},\r\n  \tsum(){\r\n  \t\treturn this.$store.state.sum\r\n  \t},\r\n  \tbigSum(){\r\n  \t\treturn this.$store.getters.bigSum\r\n  \t}\r\n  },\r\n  \t上面这样写又出现了代码冗余，观察发现只需要计算属性名和state对象中的属性名即可获得计算属性。\r\n  \t因此导入Vuex中的一个方法可以帮我们简写计算属性：import {mapState} from 'vuex'\r\n  \t该方法的参数可以是一个对象，也可以是一个数组。该方法返回一个对象。用于帮助我们映射state中的数据为计算属性。\r\n  \t\t\t对象形式的参数：mapState({school:'school',subject:'subject',sum:'sum'})\r\n  \t对象中是一个个的键值对，键代表计算属性的名字，值代表state中的属性名。注意值如果不是变量名一定要加引号。\r\n  \t这里不能使用对象的简写形式，因为对象的简写形式是键和值相同，值要是一个变量且变量名要和键名相同才能简写。而这里值不是一个变量，只是一个普通字符串。\r\n  \t\t\t上面对象形式的参数不能使用简写形式，使用数组形式的参数可以简写：mapState(['school','subject','sum'])\r\n  \t使用数组形式的参数的前提是计算属性名和state对象中的属性名是同名的。\r\n  \t若计算属性名和state对象中的属性名不同，则只能使用对象形式的参数。比如mapState({xuexiao:'school'})\r\n  \t\t\t同理，也可以将Store插件中的getters配置项中的计算属性转化成当前组件的计算属性。\r\n  \t导入mapGetters方法：import { mapGetters } from 'vuex'，其余的和mapState的使用方式一样。\r\n  \t\t*/\n  // mapXxx()返回的是一个对象，而对象不能直接写在computed对象中，因此可以使用展开运算符，将对象中的属性添加到computed中。\n  computed: {\n    ...mapState(['school', 'subject', 'sum']),\n    // 使用数组形式的参数\n    ...mapGetters({\n      bigSum: 'bigSum'\n    }) // 使用对象形式的参数\n    /* \r\n    \t展开后相当于：\r\n    \tschool:function(){\r\n    \t\treturn this.$store.state.school\r\n    \t},\r\n    \tsubject(){\r\n    \t\treturn this.$store.state.subject\r\n    \t},\r\n    \tsum(){\r\n    \t\treturn this.$store.state.sum\r\n    \t},\r\n    \tbigSum(){\r\n    \t\treturn this.$store.getters.bigSum\r\n    \t}\r\n    \t\t*/\n  },\n\n  methods: {\n    // increment(){\n    // \tconsole.log(this)\n    // \tthis.$store.dispatch('increment',this.n)\n    // },\n    /* \r\n    \t像上面这个操作没有处理逻辑，调用dispatch()通知actions，actions收到后直接就调用commit()给mutations了\r\n    \t一般这种不需要逻辑处理的操作，可以直接调用commit()通知mutations操作数据。如下所示：\r\n    */\n    // decrement(){\n    // \tthis.$store.commit('DECREMENT',this.n)\n    // },\n\n    /* \r\n    \t下面两个操作需要处理逻辑，所以需要经过actions处理，所以需要调用dispatch()（当然完全可以将逻辑写在下面方法中，这里只是为了演示Vuex的流程，）\r\n    */\n    // incrementOdd(){\n    // \tthis.$store.dispatch('incrementOdd',this.n)\n    // },\n    // incrementWait(){\n    // \tthis.$store.dispatch('incrementWait',this.n)\n    // },\n\n    /*\r\n    \t观察到methods中的方法代码也很冗余，既然有了mapState和mapGetters将state和getters中的数据映射为计算属性，\r\n    \t那也会有对应的方法将actions和mutations中的方法映射为当前组件的方法。它们分别是mapActions、mapMutations。\r\n    \tmapMutations()的第一个参数为生成的方法名，第二个参数为mutations对象中的方法名。\r\n    \t借助mapMutations生成对应的方法，方法中会调用commit去联系mutations对象中的方法。\r\n    \tmapActions()的第一个参数为生成的方法名，第二个参数为actions对象中的方法名。\r\n    \t借助mapActions生成对应的方法，方法中会调用dispatch去联系actions对象中的方法。\r\n    \t需要注意的是需要给生成的方法传入参数需要在该方法调用的时候在小括号中传入参数。\r\n    \t\t*/\n    ...mapMutations(['increment', 'decrement']),\n    ...mapActions(['incrementOdd', 'incrementWait'])\n  },\n  mounted() {\n    this.icre;\n  }\n};","map":{"version":3,"names":["mapState","mapGetters","mapActions","mapMutations","name","data","n","computed","bigSum","methods","mounted","icre"],"sources":["src/components/Count.vue"],"sourcesContent":["<template>\r\n\t<div>\r\n\t\t<!-- 下面插值语法中反复用到了$store.state，可以将该数据存储在计算属性中，减少代码冗余 -->\r\n\t\t<!-- <h1>我在{{$store.state.school}} 学习{{$store.state.subject}}</h1> -->\r\n\t\t<!-- <h1>当前求和为：{{$store.state.sum}}</h1> -->\r\n\t\t<!-- <h1>扩大十倍后：{{$store.getters.bigSum}}</h1> -->\r\n\r\n\t\t<!-- 这样就比上面简洁多了 -->\r\n\t\t<h1>我在{{school}} 学习{{subject}}</h1>\r\n\t\t<h1>当前求和为：{{sum}}</h1>\r\n\t\t<h1>扩大十倍后：{{bigSum}}</h1>\r\n\r\n\r\n\t\t<!-- 下拉框选择增加步长 -->\r\n\t\t<select v-model.number=\"n\">\r\n\t\t\t<option value=\"1\">1</option>\r\n\t\t\t<option value=\"2\">2</option>\r\n\t\t\t<option value=\"3\">3</option>\r\n\t\t</select>\r\n\t\t<button @click=\"increment\">+</button>\r\n\t\t<button @click=\"decrement\">-</button>\r\n\t\t<button @click=\"incrementOdd\">当前求和为奇数再加</button>\r\n\t\t<button @click=\"incrementWait\">等一等再加</button>\r\n\t</div>\r\n</template>\r\n\r\n<script>\r\n\t// 导入mapState、mapGetters、mapActions、mapMutations\r\n\timport {mapState,mapGetters,mapActions,mapMutations} from 'vuex'\r\n\texport default {\r\n\t\tname:'Count',\r\n\t\tdata() {\r\n\t\t\treturn {\r\n\t\t\t\tn:1, //步长默认为1\r\n\t\t\t}\r\n\t\t},\r\n\t\t/* \r\n\t\tcomputed:{\r\n\t\t\tschool(){\r\n\t\t\t\treturn this.$store.state.school\r\n\t\t\t},\r\n\t\t\tsubject(){\r\n\t\t\t\treturn this.$store.state.subject\r\n\t\t\t},\r\n\t\t\tsum(){\r\n\t\t\t\treturn this.$store.state.sum\r\n\t\t\t},\r\n\t\t\tbigSum(){\r\n\t\t\t\treturn this.$store.getters.bigSum\r\n\t\t\t}\r\n\t\t},\r\n\t\t\t上面这样写又出现了代码冗余，观察发现只需要计算属性名和state对象中的属性名即可获得计算属性。\r\n\t\t\t因此导入Vuex中的一个方法可以帮我们简写计算属性：import {mapState} from 'vuex'\r\n\t\t\t该方法的参数可以是一个对象，也可以是一个数组。该方法返回一个对象。用于帮助我们映射state中的数据为计算属性。\r\n\r\n\t\t\t对象形式的参数：mapState({school:'school',subject:'subject',sum:'sum'})\r\n\t\t\t对象中是一个个的键值对，键代表计算属性的名字，值代表state中的属性名。注意值如果不是变量名一定要加引号。\r\n\t\t\t这里不能使用对象的简写形式，因为对象的简写形式是键和值相同，值要是一个变量且变量名要和键名相同才能简写。而这里值不是一个变量，只是一个普通字符串。\r\n\r\n\t\t\t上面对象形式的参数不能使用简写形式，使用数组形式的参数可以简写：mapState(['school','subject','sum'])\r\n\t\t\t使用数组形式的参数的前提是计算属性名和state对象中的属性名是同名的。\r\n\t\t\t若计算属性名和state对象中的属性名不同，则只能使用对象形式的参数。比如mapState({xuexiao:'school'})\r\n\r\n\t\t\t同理，也可以将Store插件中的getters配置项中的计算属性转化成当前组件的计算属性。\r\n\t\t\t导入mapGetters方法：import { mapGetters } from 'vuex'，其余的和mapState的使用方式一样。\r\n\r\n\t\t*/\r\n\t\t// mapXxx()返回的是一个对象，而对象不能直接写在computed对象中，因此可以使用展开运算符，将对象中的属性添加到computed中。\r\n\t\tcomputed:{\r\n\t\t\t...mapState(['school','subject','sum']),\t// 使用数组形式的参数\r\n\t\t\t...mapGetters({bigSum:'bigSum'})\t// 使用对象形式的参数\r\n\t\t\t/* \r\n\t\t\t\t展开后相当于：\r\n\t\t\t\tschool:function(){\r\n\t\t\t\t\treturn this.$store.state.school\r\n\t\t\t\t},\r\n\t\t\t\tsubject(){\r\n\t\t\t\t\treturn this.$store.state.subject\r\n\t\t\t\t},\r\n\t\t\t\tsum(){\r\n\t\t\t\t\treturn this.$store.state.sum\r\n\t\t\t\t},\r\n\t\t\t\tbigSum(){\r\n\t\t\t\t\treturn this.$store.getters.bigSum\r\n\t\t\t\t}\r\n\r\n\t\t\t*/\r\n\t\t},\r\n\t\tmethods: {\r\n\t\t\t// increment(){\r\n\t\t\t// \tconsole.log(this)\r\n\t\t\t// \tthis.$store.dispatch('increment',this.n)\r\n\t\t\t// },\r\n\t\t\t/* \r\n\t\t\t\t像上面这个操作没有处理逻辑，调用dispatch()通知actions，actions收到后直接就调用commit()给mutations了\r\n\t\t\t\t一般这种不需要逻辑处理的操作，可以直接调用commit()通知mutations操作数据。如下所示：\r\n\t\t\t*/\r\n\t\t\t// decrement(){\r\n\t\t\t// \tthis.$store.commit('DECREMENT',this.n)\r\n\t\t\t// },\r\n\t\t\r\n\t\t\t/* \r\n\t\t\t\t下面两个操作需要处理逻辑，所以需要经过actions处理，所以需要调用dispatch()（当然完全可以将逻辑写在下面方法中，这里只是为了演示Vuex的流程，）\r\n\t\t\t*/\r\n\t\t\t// incrementOdd(){\r\n\t\t\t// \tthis.$store.dispatch('incrementOdd',this.n)\r\n\t\t\t// },\r\n\t\t\t// incrementWait(){\r\n\t\t\t// \tthis.$store.dispatch('incrementWait',this.n)\r\n\t\t\t// },\r\n\r\n\t\t/*\r\n\t\t\t观察到methods中的方法代码也很冗余，既然有了mapState和mapGetters将state和getters中的数据映射为计算属性，\r\n\t\t\t那也会有对应的方法将actions和mutations中的方法映射为当前组件的方法。它们分别是mapActions、mapMutations。\r\n\t\t\tmapMutations()的第一个参数为生成的方法名，第二个参数为mutations对象中的方法名。\r\n\t\t\t借助mapMutations生成对应的方法，方法中会调用commit去联系mutations对象中的方法。\r\n\t\t\tmapActions()的第一个参数为生成的方法名，第二个参数为actions对象中的方法名。\r\n\t\t\t借助mapActions生成对应的方法，方法中会调用dispatch去联系actions对象中的方法。\r\n\t\t\t需要注意的是需要给生成的方法传入参数需要在该方法调用的时候在小括号中传入参数。\r\n\r\n\t\t*/\r\n\t\t...mapMutations(['increment','decrement']),\r\n\t\t...mapActions(['incrementOdd','incrementWait'])\r\n\r\n\t\t},\r\n\t\tmounted(){\r\n\t\t\tthis.icre\r\n\t\t}\r\n\r\n\t}\r\n</script>\r\n\r\n<style lang=\"css\">\r\n\tbutton{\r\n\t\tmargin-left: 5px;\r\n\t}\r\n</style>\r\n"],"mappings":"AA2BA;AACA,SAAAA,QAAA,EAAAC,UAAA,EAAAC,UAAA,EAAAC,YAAA;AACA;EACAC,IAAA;EACAC,KAAA;IACA;MACAC,CAAA;IACA;EACA;;EACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;EAMA;EACAC,QAAA;IACA,GAAAP,QAAA;IAAA;IACA,GAAAC,UAAA;MAAAO,MAAA;IAAA;IACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAGA;;EACAC,OAAA;IACA;IACA;IACA;IACA;IACA;AACA;AACA;AACA;IACA;IACA;IACA;;IAEA;AACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;;IAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;IAGA,GAAAN,YAAA;IACA,GAAAD,UAAA;EAEA;EACAQ,QAAA;IACA,KAAAC,IAAA;EACA;AAEA"},"metadata":{},"sourceType":"module","externalDependencies":[]}